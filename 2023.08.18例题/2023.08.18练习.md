# 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。

**友情提醒：如果真的想好好练习哈希的话，请自觉。**

## 输入格式

第一行包含一个整数 $N$，为字符串的个数。

接下来 $N$ 行每行包含一个字符串，为所提供的字符串。

## 输出格式

输出包含一行，包含一个整数，为不同的字符串个数。

## 样例 #1

### 样例输入 #1

```
5
abc
aaaa
abc
abcc
12345
```

### 样例输出 #1

```
4
```

## 提示

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$Mmax\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$Mmax\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$Mmax\leq 1500$。


样例说明：

样例中第一个字符串( $abc$ )和第三个字符串( $abc$ )是一样的，所以所提供字符串的集合为{$aaaa$,$abc$,$abcc$,12345}，故共计4个不同的字符串。

Tip：
感兴趣的话，你们可以先看一看以下三题：

- BZOJ3097：http://www.lydsy.com/JudgeOnline/problem.php?id=3097

- BZOJ3098：http://www.lydsy.com/JudgeOnline/problem.php?id=3098

- BZOJ3099：http://www.lydsy.com/JudgeOnline/problem.php?id=3099


如果你仔细研究过了（或者至少仔细看过AC人数的话），我想你一定会明白字符串哈希的正确姿势的^\_^

# 【模板】manacher 算法

## 题目描述

给出一个只由小写英文字符 $\texttt a,\texttt b,\texttt c,\ldots\texttt y,\texttt z$ 组成的字符串 $S$ ,求 $S$ 中最长回文串的长度 。

字符串长度为 $n$。

## 输入格式

一行小写英文字符 $\texttt a,\texttt b,\texttt c,\cdots,\texttt y,\texttt z$ 组成的字符串 $S$。

## 输出格式

一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
aaa
```

### 样例输出 #1

```
3
```

## 提示

$1\le n\le 1.1\times 10^7$。

```cpp
//@winlere
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=11000002;
char data[maxn<<1];
int p[maxn<<1],cnt,ans;
inline void qr(){
      char c=getchar();
      data[0]='~',data[cnt=1]='|';
      while(c<'a'||c>'z') c=getchar();
      while(c>='a'&&c<='z') data[++cnt]=c,data[++cnt]='|',c=getchar();
}
int main(){
      qr();
      for(int t=1,r=0,mid=0;t<=cnt;++t){
	    if(t<=r) p[t]=min(p[(mid<<1)-t],r-t+1);
	    while(data[t-p[t]]==data[t+p[t]]) ++p[t];
	    //暴力拓展左右两侧,当t-p[t]==0时，由于data[0]是'~'，自动停止。故不会下标溢出。
	    //假若我这里成功暴力扩展了，就意味着到时候r会单调递增，所以manacher是线性的。
	    if(p[t]+t>r) r=p[t]+t-1,mid=t;
	    //更新mid和r,保持r是最右的才能保证我们提前确定的部分回文半径尽量多。
	    if(p[t]>ans) ans=p[t];
      }
      printf("%d\n",ans-1);
      return 0;
}
```

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define MAXN 1000005
using namespace std;
char s[MAXN],ss[MAXN];
int pos,maxr;
int p[MAXN];
int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1);
	for (int i=1;i<=n;i++) ss[i<<1]=s[i],ss[(i<<1)|1]='#';
	n=(n<<1)|1,ss[0]='@',ss[1]='#';
	strcpy(s,ss);
	for (int i=1;i<=n;i++)
	{
		if (i<maxr)	p[i]=min(p[(pos<<1)-i],maxr-i);
		while (s[i-p[i]-1]==s[i+p[i]+1]) ++p[i];
		if (i+p[i]>maxr) maxr=i+p[i],pos=i;
	}
	return 0;
}
```

```cpp
#include<cstdio>

const int maxn = 11000005;

int ans;
char s[maxn];

struct PAM {
	int te, head[1 << 20], nxt[maxn], fr[maxn], pt[maxn];
	
	void add(int a, int b, int c)
	{
		int key = a * 27 + b;
		nxt[++te] = head[key & 1048575];
		head[key & 1048575] = te;
		fr[te] = key;
		pt[te] = c;
	}
	
	int find(int a, int b)
	{
		int key = a * 27 + b;
		for(int i = head[key & 1048575]; i; i = nxt[i])
			if(fr[i] == key)
				return pt[i];
		return 0;
	}
	
	int tot, lst, tail, len[maxn], fail[maxn];
	char str[maxn];
	
//	int ch[maxn][26];
	
	void init()
	{
		fail[1] = 0;
		fail[2] = 1;
		str[0] = -1;
		len[1] = -1;
		len[2] = 0;
		tot = 2;
		lst = 1;
	}
	
	int jump(int x)
	{
		for(; str[tail] ^ str[tail - len[x] - 1]; x = fail[x]);
		return x;
	}
	
	void Extend(char ct)
	{
		str[++tail] = ct;
		int p = jump(lst);
		int ch = find(p, ct - 'a');
		if(!ch)
		{
			int q = ++tot;
			len[q] = len[p] + 2;
			if(len[q] > ans) ans = len[q];
			fail[q] = (p > 1 ? find(jump(fail[p]), ct - 'a') : 2);
			add(p, ct - 'a', ch = q);
		}
		lst = ch;
	}
}T;

int main()
{
	T.init();
	scanf("%s", s);
	for(int i = 0; s[i]; i ++) T.Extend(s[i]);
	printf("%d", ans);
	return 0;
}
```

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#define maxn 51000100
using namespace std;
int n,hw[maxn],ans;
char a[maxn],s[maxn<<1];
void manacher()
{
    int maxright=0,mid;
    for(int i=1;i<n;i++)
    {
        if(i<maxright)
            hw[i]=min(hw[(mid<<1)-i],hw[mid]+mid-i);
        else
            hw[i]=1;
        for(;s[i+hw[i]]==s[i-hw[i]];++hw[i]);
        if(hw[i]+i>maxright)
        {
            maxright=hw[i]+i;
            mid=i;
        }
    }
}
void change()
{
    s[0]=s[1]='#';
    for(int i=0;i<n;i++)
    {
        s[i*2+2]=a[i];
        s[i*2+3]='#';
    }
    n=n*2+2;
    s[n]=0;
}
int main()
{
    scanf("%s",a);
    n=strlen(a);
    change();
    manacher();
    ans=1;
    for(int i=0;i<n;i++)
        ans=max(ans,hw[i]);
    printf("%d",ans-1);
    return 0; 
}
```